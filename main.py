# выводим условия в консоль
print('''Введите конфигурацию поля. 
Каждый знак должен идти через пробел в формате:
X O X
- - X
O X O
Где:
X это крестик
O это нолик
- это пусто.
Раскладка английская.
Введите поле:''')

# считывание поля и разбиение на одномерный массив, содержащий 'X' 'O' '-'
l1 = input().split(sep=" ")
l2 = input().split(sep=" ")
l3 = input().split(sep=" ")

# заполнение массива поля игры элементами ввода
board = [
    l1[0], l1[1], l1[2],
    l2[0], l2[1], l2[2],
    l3[0], l3[1], l3[2]
]

# определение игрока и противника, за которого будет играть компьютер
player = 'X'
opponent = 'O'

# массив содержащий все победные комбинации (то к чему стремится результат)
winning_combinations = [
    [0, 1, 2],  # OOO | --- | ---
    [3, 4, 5],  # --- | OOO | ---
    [6, 7, 8],  # --- | --- | OOO

    [0, 3, 6],  # O-- | -O- | --O
    [1, 4, 7],  # O-- | -O- | --O
    [2, 5, 8],  # O-- | -O- | --O

    [0, 4, 8],
    [2, 4, 6]
    # O-- --O
    # -O- -O-
    # --O O--
]


# вывод игрового поля
def print_board():
    '''
    выводит поле на экран. Не принимает никаких входных данных
    :return: Не возвращает значения. Выводит поле в консоль
    '''
    print(board[0], board[1], board[2])
    print(board[3], board[4], board[5])
    print(board[6], board[7], board[8])
    print()


# исходя из результатов поля, фунция сравнивает текущкк положение со всеми
# выигрышными комбинациями
def is_winner(player):
    '''
    проверяет является ли player победителем (собраны ли комбинации за player)
    :param player: может принимать только 'X' 'O' в значениях - сущность за которую ведётся подсчёт
    :return: возвращает True/False
    True - если данный player победил
    False - если нет
    '''
    for combination in winning_combinations:
        if board[combination[0]] == board[combination[1]] == board[combination[2]] == player:
            return True
    return False


# функция ставит крестик или нолик в определенное место игрового поля
def make_move(move, player):
    '''
    меняет значение массива board на player
    :param move: принимает индекс хода, который будет совершён
    :param player: может принимать только 'X' 'O' в значениях - тот, за кого делается ход
    :return: ничего не возвращает
    '''
    board[move] = player


# функция убирает крестик или нолик в определенном месте игрового поля
# далее она потребуется для самого минмакса
def undo_move(move):
    '''
    Отменяет ход. Нужно для успешного выполнения алогиртмов при расчёте теоретических ходов.
    :param move: принимает индекс хода, который будет отменён (заменён на '-')
    :return: ничего не возвращает
    '''
    board[move] = '-'


# алгоритм минимаксов для нахождения самого удачного варианта
def minimax(depth, maximizing_player):
    '''
    алгоритм минимакс представляет из себя рекурсивный алгоритм создания дерева (комбинаций) ходов и
    подсчётом ожидаемого результата КОНКРЕТНОГО хода
    :param depth: глубина (ступень) дерева рекурсии
    :param maximizing_player: "степень сложности игры"
    :return: возвращает максимальное значение, которое можно получить сделав данный ход
    '''
    # Base cases

    if is_winner(player):
        return 1  # возвращаем 1 если победителем является ТЕКУЩИЙ игрок
    if is_winner(opponent):
        return -1  # возвращаем -1 если победителем является противник

    if maximizing_player:
        # ищем максимально хороший вариант выигрыша путём рекурсии и перебора всех свободных '-' ячеек на поле
        max_score = float('-inf')                                   # максимальный счет в начале крайне мал (любое
                                                                    # число больше него)
        for move in range(9):                                       # идём по всем клеткам поля
            if board[move] == '-':                                  # пуста ли ячейка
                make_move(move, player)                             # ставим ход (не афишируя игроку)
                score = minimax(depth + 1, False)   # определяем счёт на потомке данной ступени древа
                undo_move(move)                                     # убираем ход для того чтобы поле осталось прежним
                max_score = max(max_score, score)                   # ищем максимально удачную комбинацию в дереве рекурсией
        return max_score  # возвращаем максимальный счёт

    else:
        min_score = float('inf')                                    # делаем число крайне большим (любое число меньше этого)
        for move in range(9):                                       # идём по всем клеткам поля
            if board[move] == '-':                                  # пуста ли ячейка
                make_move(move, opponent)                           # ставим ход (не афишируя игроку)
                score = minimax(depth + 1, True)                    # определяем счёт на потомке данной ступени древа рекурсией
                undo_move(move)                                     # убираем ход для того чтобы поле осталось прежним
                min_score = min(min_score, score)                   # ищем минимально удачную комбинацию в дереве рекурсией
        return min_score # возвращаем минимальный счёт


#
def find_best_move():
    '''
    Находится лучшее решение для текущего игрока
    :return: лучших ход
    '''
    best_score = float('-inf')                                      # лучший счет задаётся слишком маленьким
    best_move = None                                                # объявляется переменная лучшего решения
    for move in range(9):                                           # перебираются все ячейки
        if board[move] == '-':                                      # занята ли клетка
            make_move(move, player)                                 # делаем ход не афишируя
            score = minimax(0, False)                               # смотрим сумму ходов рекурсией (minimax - ом)
            undo_move(move)                                         # отменяем ход
            if score > best_score:                                  # проверяем больше ли данный счёт чем максимально найденный до этого
                best_score = score                                  # если да то задаем значения текущего хода как максимальные
                best_move = move
    return best_move  # возвращяем лучший код

player, opponent = opponent, player
# меняем игрока и противника местами, для того чтобы рассчитать ходы для O

move = find_best_move() # находим лучший код
make_move(move, player) # делаем код
print_board()           # выводим доску


# INPUT - OUTPUT


# 1
# X X O
# X O X
# - - X

# X X O
# X O X
# O - X


# 2
# - X -
# O - -
# - - X

# - X -
# O O -
# - - X

# 3
# O - O
# - X X
# O - X

# O O O
# - X X
# O - X